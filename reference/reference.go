package reference

/*
	DO NOT EDIT THIS FILE; copy it to another folder and edit there

	The reference package is provided so that you can see how an implementation should look
	and so that the interface can be satisified as soon as created using ErrNotImplemented

	You can also use these functions in-place for any functions that you have not implemented;
	myShit.GetAll = reference.GetAll
*/

import (
	"context"

	dberrors "github.com/scottshotgg/storage/errors"
	"github.com/scottshotgg/storage/storage"
)

// DB implements Storage from the storage package
type DB struct {
	// This interface should be replaced by your implementations DB type such as `*sql.DB`
	Instance interface{}
}

// Close should call close internally on your implementations DB and clean up any lose ends; channels, waitgroups, etc
func (db *DB) Close() {
	// myDB.Instance.Close()
}

func New(name, connString string) (*DB, error) {
	// Open your DB
	// Connect/Ping to make sure it is up, etc ...

	var db = "some DB here"

	return &DB{
		Instance: &db,
	}, nil
}

// NewFrom is useful if you want to allow the end user to inject the DB
// func NewFrom(db *sql.DB) *db.DB {
// 	return &DB{
// 		Instance: db,
// 	}
// }

// All of these functions return ErrNotImplemented for now so that the interface can be satisfied

func (db *DB) Get(ctx context.Context, id string) (storage.Item, error) {
	return nil, dberrors.ErrNotImplemented
}

func (db *DB) GetBy(ctx context.Context, id, op string, value interface{}, limit int) ([]storage.Item, error) {
	return nil, dberrors.ErrNotImplemented
}

func (db *DB) GetMulti(ctx context.Context, ids ...string) ([]storage.Item, error) {
	return nil, dberrors.ErrNotImplemented
}

func (db *DB) GetAll(ctx context.Context) ([]storage.Item, error) {
	return nil, dberrors.ErrNotImplemented
}

func (db *DB) Set(ctx context.Context, item storage.Item) error {
	return dberrors.ErrNotImplemented
}

func (db *DB) SetMulti(ctx context.Context, items []storage.Item) error {
	return dberrors.ErrNotImplemented
}

func (db *DB) Delete(id string) error {
	return dberrors.ErrNotImplemented
}

func (db *DB) Iterator() (storage.Iter, error) {
	return nil, dberrors.ErrNotImplemented
}

func (db *DB) IteratorBy(key, op string, value interface{}) (storage.Iter, error) {
	return nil, dberrors.ErrNotImplemented
}

func (db *DB) GetChangelogsForObject(id string) ([]storage.Changelog, error) {
	return nil, dberrors.ErrNotImplemented
}

func (db *DB) GetLatestChangelogForObject(id string) (*storage.Changelog, error) {
	return nil, dberrors.ErrNotImplemented
}

func (db *DB) DeleteChangelogs(ids ...string) error {
	return dberrors.ErrNotImplemented
}

func (db *DB) ChangelogIterator() (storage.ChangelogIter, error) {
	return nil, dberrors.ErrNotImplemented
}

// storage.Changelog stuff: move this to it's own file

// DeleteBy
// DeleteMulti
// DeleteAll() error
